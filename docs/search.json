[
  {
    "objectID": "settings.html",
    "href": "settings.html",
    "title": "Settings",
    "section": "",
    "text": "Throughout the workshop, we will use VScode and leverage Docker. To follow the workshop materials and run the code, you will need the following tools install and set:\nPlease check the sections below for guidance on setting up the above requirements.",
    "crumbs": [
      "Home",
      "Settings"
    ]
  },
  {
    "objectID": "settings.html#workshop-materials",
    "href": "settings.html#workshop-materials",
    "title": "Settings",
    "section": "Workshop Materials",
    "text": "Workshop Materials\nAll the workshop materials avaialble on the below repository:\nhttps://github.com/RamiKrispin/R-Medicine-VScode-Workshop\nPlease fork and clone to your local machine.",
    "crumbs": [
      "Home",
      "Settings"
    ]
  },
  {
    "objectID": "settings.html#setting-docker",
    "href": "settings.html#setting-docker",
    "title": "Settings",
    "section": "Setting Docker",
    "text": "Setting Docker\nVarious ways exist to build and run Docker images on different operations systems. For the purpose of this guide, we will be utilizing Docker Desktop. It is a user-friendly container management interface that is compatible with MacOS, Windows, and Linux operating systems.\nNote: Docker Desktop is free for personal use but requires a license for commercial use. For further information, please refer to https://www.docker.com/pricing/.\nTo install Docker Desktop, go to Docker website and follow the installation instructions according to your OS:\n\n\n\nFigure 1 - Docker Desktop download page",
    "crumbs": [
      "Home",
      "Settings"
    ]
  },
  {
    "objectID": "settings.html#docker-hub",
    "href": "settings.html#docker-hub",
    "title": "Settings",
    "section": "Docker Hub",
    "text": "Docker Hub\nContainer Registry has a similar functionality as Github for code, and it uses to store and share images. There are many container registries, and the most common is Docker Hub. We will use throughout the tutorial Docker Hub to pull different images, such as Python built-in images. To register and create an account go to https://hub.docker.com and follow the registration instructions.\nAfter installing Docker Desktop and setting account on Docker Hub, open Docker Desktop, and from the command line, login to Docker Hub:\n docker login\nYou will have to enter your username and password, and you should expect the following output if the login is successful:\nLogin with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.\nUsername: rkrispin\nPassword:\nLogin Succeeded\n\nLogging in with your password grants your terminal complete access to your account.\nFor better security, log in with a limited-privilege personal access token. Learn more at https://docs.docker.com/go/access-tokens/\nNote: Docker Hub is completely public (for the free tier). Any image you push and store there will be available for all other users. Regardless if your container registry is public or not, NEVER store credentials, passwords, or any other sensitive information on your Docker images.\n\nHello World!\nThere is no better way to test if Docker was installed properly than by running whalesay (or üê≥ say) Docker‚Äôs most Hello World! common example. The whalesay is an adaption of the Linux cowsay (üêÆ say) game using a whale instead of a cow to print some text. Let‚Äôs run the below code from the terminal to print Welcome to the Docker for Data Science Workshop! üëãüèº:\ndocker run docker/whalesay cowsay Welcome to the Setting Up a Dockerized R Development Environment with VScode Workshop! üëãüèº\nIf this is the first time you are using Docker or your first time using the whalesay image you should expect the following message:\nUnable to find image 'docker/whalesay:latest' locally\nThat is a generic message that notifies that the requested image cannot be found locally, and Docker will try to pull the image from the hub (if specified) and follow by downloading the image:\nlatest: Pulling from docker/whalesay\nImage docker.io/docker/whalesay:latest uses outdated schema1 manifest format. Please upgrade to a schema2 image for better future compatibility. More information at https://docs.docker.com/registry/spec/deprecated-schema-v1/\ne190868d63f8: Pull complete\n909cd34c6fd7: Pull complete\n0b9bfabab7c1: Pull complete\na3ed95caeb02: Pull complete\n00bf65475aba: Pull complete\nc57b6bcc83e3: Pull complete\n8978f6879e2f: Pull complete\n8eed3712d2cf: Pull complete\nDigest: sha256:178598e51a26abbc958b8a2e48825c90bc22e641de3d31e18aaf55f3258ba93b\nStatus: Downloaded newer image for docker/whalesay:latest\nAnd this is the expected output:\n/ Welcome to the Setting Up a Dockerized \\\n| R Development Environment with VScode  |\n\\ Workshop! üëãüèº                     /\n ----------------------------------------\n    \\\n     \\\n      \\\n                    ##        .\n              ## ## ##       ==\n           ## ## ## ##      ===\n       /\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"___/ ===\n  ~~~ {~~ ~~~~ ~~~ ~~~~ ~~ ~ /  ===- ~~~\n       \\______ o          __/\n        \\    \\        __/\n          \\____\\______/\nIf you are able to run the whalesay app you are ready to get started with Docker.",
    "crumbs": [
      "Home",
      "Settings"
    ]
  },
  {
    "objectID": "settings.html#installing-vscode",
    "href": "settings.html#installing-vscode",
    "title": "Settings",
    "section": "Installing VScode",
    "text": "Installing VScode\nInstalling VScode is straightforward - go to the VScode website https://code.visualstudio.com/ and click on the Download button (purple rectangle on the screenshot):\n\n\n\nFigure 2 - Visual Studio Code download page\n\n\nDownload the installation file and follow the instructions.\n\nInstall the Dev Containers Extension\nLast but not least, we will install the Dev Containers extension following the below steps:\n\nClick the Extensions button on the left menu (mark with a purple arrow on the screenshot below)\nType the extension name - Dev Containers, on the search menu (see the yellow rectangular). You can see the search results below, and clicking on each extension will open a window with the extension details.\nLast but not least, Click the install button (see the green rectangular) to install the extension\n\n\n\n\nFigure 3 - Steps to install extension on VScode\n\n\n\nNote: The Dev Containers extension is required to launch the dockerized environment. We will see later in this tutorial how to set and install the necessary extensions for your dockerized environment automatically with the devcontainer.json file.",
    "crumbs": [
      "Home",
      "Settings"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction üê≥",
    "section": "",
    "text": "Materials for the R/Medicine 2024 conference Setting Up a Dockerized R Development Environment with VScode workshop.",
    "crumbs": [
      "Home",
      "Introduction üê≥"
    ]
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "Introduction üê≥",
    "section": "Prerequisites",
    "text": "Prerequisites\nThe workshop required basic knowledge of the following:\n\nCLI commands\nBash scripting\n\nIt is nice to have knowledge of Docker and working with containers. The first hour of the workshop will be dedicated to Docker.",
    "crumbs": [
      "Home",
      "Introduction üê≥"
    ]
  },
  {
    "objectID": "index.html#requirements",
    "href": "index.html#requirements",
    "title": "Introduction üê≥",
    "section": "Requirements",
    "text": "Requirements\nIf you want to follow along with the code examples during the workshop, you should have the following tools installed:\n\nDocker\nDocker Hub account\nVScode\nThe Dev Containers extension",
    "crumbs": [
      "Home",
      "Introduction üê≥"
    ]
  },
  {
    "objectID": "index.html#schedule",
    "href": "index.html#schedule",
    "title": "Introduction üê≥",
    "section": "Schedule",
    "text": "Schedule\nThe workshop will take place on Tuesday, June 11, 2024 from 2:30-5:30pm EST.",
    "crumbs": [
      "Home",
      "Introduction üê≥"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Introduction üê≥",
    "section": "License",
    "text": "License\nThis workshop is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.",
    "crumbs": [
      "Home",
      "Introduction üê≥"
    ]
  },
  {
    "objectID": "cli-commands.html",
    "href": "cli-commands.html",
    "title": "CLI Commands",
    "section": "",
    "text": "This section focuses on the command line (CLI) core commands. Typically, when working with Docker and containers, we will use some flavor of Linux OS, such as Ubuntu, Alpine, etc. Throughout this workshop, we will use Ubuntu unless stated otherwise. We will start by pulling the official Ubuntu image and launch a container using the run command from the terminal:\nWe use the interactive and tty arguments to ssh inside the container:\nThis will ssh into the container terminal:",
    "crumbs": [
      "Home",
      "CLI Commands"
    ]
  },
  {
    "objectID": "cli-commands.html#basic-cli-commands",
    "href": "cli-commands.html#basic-cli-commands",
    "title": "CLI Commands",
    "section": "Basic CLI Commands",
    "text": "Basic CLI Commands\nThe ls command lists the files and directories in the current directory (or a different directory when provided a path):\nroot@0e52c467700c:/# ls\nbin  boot  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\nBy default, the ls command won‚Äôt display hidden files (e.g., starts with .). To display all files, use the -a argument:\nroot@0e52c467700c:/# ls -a\n.  ..  .dockerenv  bin  boot  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\nSimilarly, the -l argument will display the output in a long listing format:\nroot@0e52c467700c:/# ls -l\ntotal 48\nlrwxrwxrwx   1 root root    7 Jan 25 14:04 bin -&gt; usr/bin\ndrwxr-xr-x   2 root root 4096 Apr 18  2022 boot\ndrwxr-xr-x   5 root root  360 Feb  4 06:39 dev\ndrwxr-xr-x   1 root root 4096 Feb  4 06:39 etc\ndrwxr-xr-x   2 root root 4096 Apr 18  2022 home\nlrwxrwxrwx   1 root root    7 Jan 25 14:04 lib -&gt; usr/lib\ndrwxr-xr-x   2 root root 4096 Jan 25 14:04 media\ndrwxr-xr-x   2 root root 4096 Jan 25 14:04 mnt\ndrwxr-xr-x   2 root root 4096 Jan 25 14:04 opt\ndr-xr-xr-x 286 root root    0 Feb  4 06:39 proc\ndrwx------   2 root root 4096 Jan 25 14:09 root\ndrwxr-xr-x   5 root root 4096 Jan 25 14:09 run\nlrwxrwxrwx   1 root root    8 Jan 25 14:04 sbin -&gt; usr/sbin\ndrwxr-xr-x   2 root root 4096 Jan 25 14:04 srv\ndr-xr-xr-x  12 root root    0 Feb  4 06:39 sys\ndrwxrwxrwt   2 root root 4096 Jan 25 14:09 tmp\ndrwxr-xr-x  11 root root 4096 Jan 25 14:04 usr\ndrwxr-xr-x  11 root root 4096 Jan 25 14:09 var\nThe cd command enables to change the shell working directory:\nroot@0e52c467700c:/# cd bin\nroot@0e52c467700c:/bin#\nThe pwd returns the current working directory:\nroot@0e52c467700c:/bin# pwd\n/bin\nLast but not least, the .. reference the directory above the current path:\ncd ..\nroot@0e52c467700c:/#",
    "crumbs": [
      "Home",
      "CLI Commands"
    ]
  },
  {
    "objectID": "cli-commands.html#working-with-files-and-directories",
    "href": "cli-commands.html#working-with-files-and-directories",
    "title": "CLI Commands",
    "section": "Working with files and directories",
    "text": "Working with files and directories\nThe mkdir (i.e., make directory) command enables to create a directory:\nroot@0e52c467700c:/# mkdir test\nroot@0e52c467700c:/# cd test/\nroot@0e52c467700c:/test#\nThere are many ways to create and view files via the CLI. In the following example, we will create a bash script named hellow_world.sh that print Hello World!. We will use the touch command to create an empty bash script file:\nroot@0e52c467700c:/test# touch hello_world.sh\nYou can use the ls command to confirm that the file was created:\nroot@0e52c467700c:/test# ls\nhello_world.sh\nIn the CLI, the echo command is used to print text and can be used to write text into a file with the &gt; symbol. As we want the bash script to print Hello World! we will write to the file echo \"Hello World!\":\necho echo \"Hello World!\" &gt; hello_world.sh\nTo print the content of the file, we will use the cat command:\nroot@0e52c467700c:/test# cat hello_world.sh\necho Hello World!\nWe can now execute the file using the bash command:\nroot@0e52c467700c:/test# bash hello_world.sh\nHello World!\nNote: The &gt; symbol is used to add new text to a file. If the file already has any text, it will overwrite the previous text with the new text. To append new text, use the &gt;&gt; symbol:\nroot@0e52c467700c:/test# echo echo \"Hello World 2!\" &gt;&gt; hello_world.sh\nroot@0e52c467700c:/test# cat hello_world.sh\necho Hello World!\necho Hello World 2!\nroot@0e52c467700c:/test# bash hello_world.sh\nHello World!\nHello World 2!\nThe rm command (i.e., remove), enables to delete or remove files and folders. For example, let‚Äôs now delete the bash script we created above - hello_world.sh:\nroot@0e52c467700c:/test# rm hello_world.sh\nYou can use the ls command to confirm that the file was deleted:\nroot@0e52c467700c:/test# ls\nroot@0e52c467700c:/test#\nSimilarly, you can use the rm command to delete folders. Let‚Äôs remove the test folder we created:\nrm -rf test/\nThe r arguments are used to remove directories and their contents recursively, and the f argument to ignore nonexistent files and arguments.",
    "crumbs": [
      "Home",
      "CLI Commands"
    ]
  },
  {
    "objectID": "cli-commands.html#variables",
    "href": "cli-commands.html#variables",
    "title": "CLI Commands",
    "section": "Variables",
    "text": "Variables\nAnother common use case of command line functionality is the use of variables and environment variables. Assigning values to variables from the CLI is straightforward and fairly similar to other programming languages, such as R and Python, using the = symbol. For example, let‚Äôs assign the variable x the value 10:\nroot@0e52c467700c:/# x=10\nNote:Unlike R or Python, the CLI is sensitive to spaces when assigning values to variables. Using spaces would end up with error as it\nroot@0e52c467700c:/# x = 10\nbash: x: command not found\nSimilarly, typing the variable name would end up with an error, as the shell interpreter is expecting a command. For example, the below code would results in an error:\nroot@0e52c467700c:/# x\nbash: x: command not found\nTo refer to variables on the CLI, attach the $ sign before the variable name. For example, we will use the echo command to print the variable x we created above:\nroot@0e52c467700c:/# echo $x\n10\n\nAssign Variable to Bash Script\nWhen building containers, we often use bash scripts as helper files. For example, the following bash script is used to install Quarto during the build time of the image with the use of variables. It has the following functionality: - Receive input from the user with the Quarto version and assign the value to a variable name QUARTO_VERSION - Use the uname command to evaluate the CPU type and assign it to a variable name CPU - Use the wget function to pull the relevant Quarto build and install it with the dpkg function\ninstall_quarto.sh\n#!/usr/bin/env bash\nQUARTO_VERSION=$1 \n\necho \"Installing Quarto version $QUARTO_VERSION\"\n\n# Identify the CPU type (M1 vs Intel)\nif [[ $(uname -m) ==  \"aarch64\" ]] ; then\n  CPU=\"arm64\"\nelif [[ $(uname -m) ==  \"arm64\" ]] ; then\n  CPU=\"arm64\"\nelse\n  CPU=\"amd64\"\nfi\n\nTEMP_QUARTO=\"$(mktemp)\" && \\\n    wget -q  -O \"$TEMP_QUARTO\" https://github.com/quarto-dev/quarto-cli/releases/download/v$QUARTO_VERSION/quarto-${QUARTO_VERSION}-linux-${CPU}.deb && \\\n    dpkg -i \"$TEMP_QUARTO\" && \\\n    rm -f \"$TEMP_QUARTO\"\nHere is how you would execute the script:\nbash install_quarto.sh \"1.3.450\"\nWhere bash will index the variables by their order of assignment starting with 1. In the above case, as we have a single variable, it will be indexed as 1 and referenced in the script as $1\n\n\nSetting Environment Variables\nThe use of environment variables in the Docker development workflow is a very useful tool. It enables you to unify your settings with having multiple users. In addition, it enables you to parameterize your settings and avoid hard-coding some of the functionality of your image, such as the R or Python versions. We use the export command on the CLI to set an environment variable. For example, let‚Äôs reset x as an environment variable and assign the value 10 from the CLI:\nroot@0e52c467700c:/# export x=10\nroot@0e52c467700c:/# echo $x\n10\nOn Linux distro, you typically use the bash .bashrc file to add your setting and set environment variables. For example, if we want to set the x variabe we created before as environment variable we would add the",
    "crumbs": [
      "Home",
      "CLI Commands"
    ]
  },
  {
    "objectID": "docker-intro.html",
    "href": "docker-intro.html",
    "title": "Introduction to Docker",
    "section": "",
    "text": "In my data science career, one major technical milestone (after learning how to code and adopt Git) was learning Docker and starting to use it. It opened a new world of opportunities, from automating processes to deploying data science work in production. This section defines what Docker is and the data science applications and use cases.",
    "crumbs": [
      "Home",
      "Introduction to Docker"
    ]
  },
  {
    "objectID": "docker-intro.html#what-is-docker",
    "href": "docker-intro.html#what-is-docker",
    "title": "Introduction to Docker",
    "section": "What is Docker?",
    "text": "What is Docker?\nDocker is a CI/CD tool that enables seamless code deployment from development to production environments. By creating OS-level virtualization, it can package an application and its dependencies in a virtual container and ship it between different environments. The main advantages of using Docker within your development environment are:\n\nReproducibility - Docker enables you to seamlessly package your code and its dependencies into a single container and execute, test, share, and deploy it with a high level of consistency\nCollaboration - Docker solves the dependencies madness when a team of developers works together on a specific project. Having a unified environment saves a ton of time during the development step. For example, if one developer gets some error, it is easy for other developers to reproduce the error and help debug it\nDeployment - Docker simplifies the code shipment from the development environment to the production",
    "crumbs": [
      "Home",
      "Introduction to Docker"
    ]
  },
  {
    "objectID": "docker-intro.html#docker-for-data-science",
    "href": "docker-intro.html#docker-for-data-science",
    "title": "Introduction to Docker",
    "section": "Docker for Data Science",
    "text": "Docker for Data Science\nDocker was built to solve a common DevOps problem - the lack of reproducibility when shifting code between different environments (e.g., dev to prod). Reproducibility is not limited to DevOps, and it plays a critical role in the field of data science. We can define reproducibility as the ability to generate the exact outcome when running the same code regardless of the user or machine on which the code is running.\nThe first time I heard the term reproducibility was during my bachelor‚Äôs degree, where I learned that reproducibility starts and ends by setting a seed number to lock down random numbers. My favorite seed number is 12345. When I started to work as a data scientist, I realized that reproducibility goes beyond setting a seed number. Here are the main elements that can impact code reproducibility:\n\nVersion control ‚Äî First and foremost, reproducing the same results starts with the ability to track changes in your code Randomization ‚Äî Controlling the random generation of numbers by setting the seed number\nSoftware version ‚Äî The versions of your Python or R (or any other programming language) and its dependencies (e.g., libraries) impact the outcome of your code. For example, code that was built with pandas v1.0 may not run on v2.0 due to deprecation of functions\nOperating System (OS) ‚Äî Most programming languages, particularly R and Python, use different compilers (e.g., C, C++, etc.) and other built-in OS components. The type of OS and its version could impact the outcome of your code\nHardware ‚Äî Last but not, the type of hardware (or infrastructure) could impact your results (ARM/Intel/Apple processor, etc)\n\nIn a regular data science workflow, reproducibility is dependent on several factors. One of the most basic and trivial elements of reproducibility is code versioning. Using unversioned code makes it impossible to track changes in your code or verify that the same code runs on different environments.\nAnother critical factor is package versioning. Over time, packages and their dependencies tend to change and evolve, get new features, bug fixes, replace and deprecate old functions. In some cases, running your code using a specific package version may not work or yield the same results as older or newer versions of the package. For example, code written with Pandas 1.x may not work with Pandas 2.x, and vice versa.\nSimilarly, programming languages tend to change over time, and using code built with older versions may not work or be supported with recent ones. Moreover, different operating systems use different software architectures or run different types of compilers (c, c++, etc.) on the backend. This difference may impact the reproducibility of your code.\nLastly, the type of CPU architecture (ARM, Intel, Apple Silocon, etc.) may impact the underlying software. Some packages or software may require a separate build or may not be supported, which can ultimately affect the reproducibility of your code.\nBelow is Figure 1, which illustrates the factors affecting code reproducibility when transferring between different environments.\n\n\n\n\nFigure 1 - Shifting code between environments, what could go wrong?\n\n\n\nGit provides a solution for versioning and monitoring code, ensuring that it can be reproduced correctly regardless of the user or machine it runs on, as long as it is used properly. Docker and similar solutions address the problem of environment mismatches by creating an isolated environment within a container that can be shipped along with the code to any remote machine, such as a desktop, laptop or server, allowing for seamless reproduction of the process.\nWhile developing software on different hardware architectures, such as Apple Silicon and Intel-based machines, there may be potential differences in the environment. Docker can partially address this issue by creating a dedicated image for each CPU architecture. However, this approach can be time-consuming and expensive since additional tests are required to ensure that all containers have the exact same characteristics.\nFigure 2 demonstrates a general workflow with Docker and Git. We use Git and Github/Gitlab/Bitbucket (or any similar service) to code version control. Docker is used to set up a containerized environment, which will be used for code development and testing. We then shift our code with the container to any remote environment that supports containers (i.e., Github Actions, AWS, GCP, etc.).\n\n\n\n\nFigure 2 - Shifting code between environments with version control and containers\n\n\n\nWhile this workflow provides a high level of reproducibility, it does not cover reproducibility issues you may encounter due to different hardware settings. There are different methods to address this issue, such as building a dedicated environment for each hardware architecture.\nNote: Using a virtual environment is not an alternative to Docker. It actually works well together. While VE is not in the scope of this tutorial, you can read more about the differences between VE and Docker in the following article.",
    "crumbs": [
      "Home",
      "Introduction to Docker"
    ]
  },
  {
    "objectID": "docker-pull.html",
    "href": "docker-pull.html",
    "title": "Docker Pull",
    "section": "",
    "text": "WIP\nThe docker pull command, as the name implies, enables us to pull images from an image registery service to the local machine. Likewise, the docker push command enables to push images from the local machine to the image registery.\nThroughout the workshop, we will use Docker Hub to pull and push images. Before getting started, make sure that the Docker Desktop is open and login to your Docker Hub account using the docker login command:\n docker login\nYou will have to enter your Docker Hub username and password, and you should expect the following output if the login is successful:\nLogin with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.\nUsername: rkrispin\nPassword:\nLogin Succeeded\n\nLogging in with your password grants your terminal complete access to your account.\nFor better security, log in with a limited-privilege personal access token. Learn more at https://docs.docker.com/go/access-tokens/\nNext, let‚Äôs use the docker pull command to pull r-base image from the Rocker project:\ndocker pull rocker/r-base\nBy default, if image tag is not specify, it will pull the latest version, in this case tagged as latest:\nlatest: Pulling from rocker/r-base\ndd55a40fdbce: Pull complete\nf5be2f3d564a: Pull complete\n871f8609f7aa: Pull complete\n4341d4d0ed70: Pull complete\ndb1a17629c49: Pull complete\n1b6d85ef75d6: Pull complete\nDigest: sha256:76d5085d8f7f956d657fa8157119ee721e200768ebf4238e8eb7622963741a52\nStatus: Downloaded newer image for rocker/r-base:latest\ndocker.io/rocker/r-base:latest\nYou can notice from above log that Docker pulls the images by its layers. Each layer has a unique identifier and if it already exists in the local machine it will use. We can use the docker images command to review the image details:\ndocker images\nAnd you should expect the below output:\nREPOSITORY                                                                      TAG           IMAGE ID       CREATED        SIZE\nrocker/r-base                                                                   latest        b45bc6363d5c   6 weeks ago    900MB\nTo get a comprehensive details on the image you can use the inspect command:\ndocker inspect rocker/r-base\nThe output includes a comprehensive metadata, such as the envornment variable, image layers and size, architecture type:\n[\n    {\n        \"Id\": \"sha256:b45bc6363d5cb106d0eb8487b063d31fdfd69303930ef9197321761a325a759c\",\n        \"RepoTags\": [\n            \"rocker/r-base:latest\"\n        ],\n        \"RepoDigests\": [\n            \"rocker/r-base@sha256:76d5085d8f7f956d657fa8157119ee721e200768ebf4238e8eb7622963741a52\"\n        ],\n        \"Parent\": \"\",\n        \"Comment\": \"buildkit.dockerfile.v0\",\n        \"Created\": \"2024-04-24T12:34:24.227798748-05:00\",\n        \"Container\": \"\",\n        \"ContainerConfig\": {\n            \"Hostname\": \"\",\n            \"Domainname\": \"\",\n            \"User\": \"\",\n            \"AttachStdin\": false,\n            \"AttachStdout\": false,\n            \"AttachStderr\": false,\n            \"Tty\": false,\n            \"OpenStdin\": false,\n            \"StdinOnce\": false,\n            \"Env\": null,\n            \"Cmd\": null,\n            \"Image\": \"\",\n            \"Volumes\": null,\n            \"WorkingDir\": \"\",\n            \"Entrypoint\": null,\n            \"OnBuild\": null,\n            \"Labels\": null\n        },\n        \"DockerVersion\": \"\",\n        \"Author\": \"\",\n        \"Config\": {\n            \"Hostname\": \"\",\n            \"Domainname\": \"\",\n            \"User\": \"\",\n            \"AttachStdin\": false,\n            \"AttachStdout\": false,\n            \"AttachStderr\": false,\n            \"Tty\": false,\n            \"OpenStdin\": false,\n            \"StdinOnce\": false,\n            \"Env\": [\n                \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n                \"LC_ALL=en_US.UTF-8\",\n                \"LANG=en_US.UTF-8\",\n                \"R_BASE_VERSION=4.4.0\"\n            ],\n            \"Cmd\": [\n                \"R\"\n            ],\n            \"ArgsEscaped\": true,\n            \"Image\": \"\",\n            \"Volumes\": null,\n            \"WorkingDir\": \"\",\n            \"Entrypoint\": null,\n            \"OnBuild\": null,\n            \"Labels\": {\n                \"org.opencontainers.image.authors\": \"Dirk Eddelbuettel &lt;edd@debian.org&gt;\",\n                \"org.opencontainers.image.licenses\": \"GPL-2.0-or-later\",\n                \"org.opencontainers.image.source\": \"https://github.com/rocker-org/rocker\",\n                \"org.opencontainers.image.vendor\": \"Rocker Project\"\n            }\n        },\n        \"Architecture\": \"amd64\",\n        \"Os\": \"linux\",\n        \"Size\": 899834336,\n        \"VirtualSize\": 899834336,\n        \"GraphDriver\": {\n            \"Data\": {\n                \"LowerDir\": \"/var/lib/docker/overlay2/8cc3007974934c112d67461ae50da63bd63100233c34cb09c94f4886d95a9d51/diff:/var/lib/docker/overlay2/6beb7739ac622c7420d0c5be0786f93e375415cbe4ec310deda1f500ef078f69/diff:/var/lib/docker/overlay2/13ccc1c83e6367b0422d6535f75044675d01846eabb92dc858d24714a14f40e0/diff:/var/lib/docker/overlay2/802733b21e8b4d2d6438066ca43305dfd77f81b0ca11722b2c1800aabc3c8b7f/diff:/var/lib/docker/overlay2/b254b8787a1e1d685b98905789cf8768b766ef3713ecff1c0256a7e0243b1eaa/diff\",\n                \"MergedDir\": \"/var/lib/docker/overlay2/dc75f5a9acdf97a2c3f1d0c48ca2fe17be9ade944a728bff41b3bd07d7beebdd/merged\",\n                \"UpperDir\": \"/var/lib/docker/overlay2/dc75f5a9acdf97a2c3f1d0c48ca2fe17be9ade944a728bff41b3bd07d7beebdd/diff\",\n                \"WorkDir\": \"/var/lib/docker/overlay2/dc75f5a9acdf97a2c3f1d0c48ca2fe17be9ade944a728bff41b3bd07d7beebdd/work\"\n            },\n            \"Name\": \"overlay2\"\n        },\n        \"RootFS\": {\n            \"Type\": \"layers\",\n            \"Layers\": [\n                \"sha256:15825d671d3afd92546b589ed5c937299492a038da84eec0e6c0674fa594823e\",\n                \"sha256:58333b745bb8d03be4c9ff93a47e50f5569ab7925fd5036339f5b26c5cfd25bd\",\n                \"sha256:7868e7ea14cebd7f057115bed94ef907e325cd706ea585e5b9bc3ea42940514a\",\n                \"sha256:c2016d4ea8f014664f67c68736f1f7c6d098c49a92f18b7ed3e4f077f87bb367\",\n                \"sha256:45c736116a28d88a37d67b485683e43dc8ead81224d4505b9237d89398ff07d1\",\n                \"sha256:8911ae004132b1e2cb1e3bb1ee798c99a667fa8dfd2650aa6780982dfe5dbf1c\"\n            ]\n        },\n        \"Metadata\": {\n            \"LastTagTime\": \"0001-01-01T00:00:00Z\"\n        }\n    }\n]\nOne thing to notice, the r-base image has an execution command (i.e., CMD) to launch R:\ndocker inspect rocker/r-base | jq '.[]| .Config.Cmd'\n[\n  \"R\"\n]",
    "crumbs": [
      "Home",
      "Docker Pull"
    ]
  }
]